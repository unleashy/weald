using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;

// Adapted from https://github.com/dtolnay/unicode-ident

var root = GetSourceRoot() ?? throw new InvalidOperationException("cannot determine source root");
var ucdBase = new Uri("https://www.unicode.org/Public/UCD/latest/ucd");

Console.WriteLine("Downloading UCD files...");
var properties = await Properties.ExtractFromWeb(ucdBase).ConfigureAwait(false);

Console.WriteLine("Computing tables...");
var tables = Tables.Compute(properties);

var path = Path.Combine(root, "Tables.g.cs");
Console.WriteLine($"Writing generated class to {path}");
WriteTables(path, properties, tables);

return;

static void WriteTables(string path, Properties properties, Tables tables)
{
    // language=C#
    const string header =
        """
        /// <auto-generated />
        /// To regenerate, run Weald.UnicodeTables.Program
        #pragma warning disable

        namespace Weald.UnicodeTables;

        internal static class Tables
        """;

    var writer = new StringWriter();
    var output = new IndentedTextWriter(writer, "    ");

    output.WriteLine(header);
    output.WriteLine("{");
    ++output.Indent;

    var asciiStart = Enumerable.Range(0, 0x7F)
        .Select(c => (UInt128) (properties.IsStart(new Rune(c)) ? 1 : 0) << c)
        .Aggregate((a, b) => a + b);

    var asciiContinue = Enumerable.Range(0, 0x7F)
        .Select(c => (UInt128) (properties.IsContinue(new Rune(c)) ? 1 : 0) << c)
        .Aggregate((a, b) => a + b);

    output.WriteLine($"public static readonly UInt128 AsciiStart = {EncodeUInt128(asciiStart)};");
    output.WriteLineNoTabs("");
    output.WriteLine(
        $"public static readonly UInt128 AsciiContinue = {EncodeUInt128(asciiContinue)};"
    );
    output.WriteLineNoTabs("");
    output.WriteLine($"public const int ChunkLength = {Chunk.Length};");
    output.WriteLineNoTabs("");

    WriteByteArray(output, "TrieStart", tables.StartIndices);
    output.WriteLineNoTabs("");
    WriteByteArray(output, "TrieContinue", tables.ContinueIndices);
    output.WriteLineNoTabs("");
    WriteByteArray(output, "Leaf", tables.HalfDense);

    --output.Indent;
    output.WriteLine("}");

    output.WriteLineNoTabs("");
    output.Flush();

    File.WriteAllText(path, writer.ToString(), Encoding.UTF8);
}

static void WriteByteArray(IndentedTextWriter output, string name, byte[] array)
{
    output.WriteLine($"// {array.Length} bytes");
    output.WriteLine($"public static readonly byte[] {name} = [");
    ++output.Indent;

    foreach (var line in array.Chunk(16)) {
        if (line.Length > 1) {
            foreach (var b in line[0 .. ^1]) {
                output.Write($"0x{b:X2}, ");
            }
        }

        output.WriteLine($"0x{line[^1]:X2},");
    }

    --output.Indent;
    output.WriteLine("];");
}

static string EncodeUInt128(UInt128 value)
{
    var upper = (ulong)(value >> 64);
    var lower = (ulong)value;
    return $"new UInt128(0x{upper:X16}, 0x{lower:X16})";
}

static string? GetSourceRoot([CallerFilePath] string path = "") => Path.GetDirectoryName(path);

file readonly record struct Properties(HashSet<Rune> NameStart, HashSet<Rune> NameContinue)
{
    public static async Task<Properties> ExtractFromWeb(Uri uri)
    {
        using var client = new HttpClient();

        var tasks = await Task.WhenAll(
            client.GetStringAsync(uri + "/DerivedCoreProperties.txt"),
            client.GetStringAsync(uri + "/PropList.txt")
        ).ConfigureAwait(false);

        var derivedPropList = tasks[0];
        var propList = tasks[1];

        return Extract(derivedPropList, propList);
    }

    private static Properties Extract(string derivedPropList, string propList)
    {
        // Start: XID_Start + ID_Compat_Math_Start + '_' - Default_Ignorable_Code_Point
        // Continue: XID_Continue + ID_Compat_Math_Continue - Default_Ignorable_Code_Point

        var starts = new HashSet<Rune>();
        var continues = new HashSet<Rune>();
        var ignorables = new HashSet<Rune>();

        var derivedFields = ParseUcd(
            derivedPropList,
            ["XID_Start", "XID_Continue", "Default_Ignorable_Code_Point"]
        );

        var propFields = ParseUcd(
            propList,
            ["ID_Compat_Math_Start", "ID_Compat_Math_Continue"]
        );

        foreach (var field in derivedFields.Concat(propFields)) {
            var relevantSet = field.Property switch {
                "XID_Start" or "ID_Compat_Math_Start"       => starts,
                "XID_Continue" or "ID_Compat_Math_Continue" => continues,
                "Default_Ignorable_Code_Point"              => ignorables,

                _ => throw new InvalidOperationException($"Unexpected property: {field.Property}"),
            };

            relevantSet.UnionWith(
                Enumerable.Sequence(field.Start, field.End, 1).Select(it => new Rune(it))
            );
        }

        // XID_Start does not include '_'
        starts.Add(new Rune('_'));

        // Remove ignorables
        starts.ExceptWith(ignorables);
        continues.ExceptWith(ignorables);

        return new Properties(starts, continues);
    }

    private static IEnumerable<UcdField> ParseUcd(string file, string[] relevantProps)
    {
        var reader = new StringReader(file);

        while (reader.ReadLine() is {} line) {
            line = line.Trim();

            if (string.IsNullOrWhiteSpace(line) || line.StartsWith('#')) {
                continue;
            }

            if (UcdField.Parse(line, relevantProps) is {} field) {
                yield return field;
            }
        }
    }

    public bool IsStart(Rune rune) => NameStart.Contains(rune);

    public bool IsContinue(Rune rune) => NameContinue.Contains(rune);
}

file readonly record struct Tables(
    byte[] StartIndices,
    byte[] ContinueIndices,
    byte[] HalfDense
)
{
    public static Tables Compute(Properties properties)
    {
        var chunkMap = new Dictionary<Chunk, byte>();
        var dense = new List<Chunk>();

        byte PutChunk(Chunk chunk)
        {
            if (chunkMap.TryGetValue(chunk, out var prev)) {
                return prev;
            }

            var index = chunkMap.Count;
            Debug.Assert(index <= byte.MaxValue, "exceeded 256 unique chunks");

            dense.Add(chunk);
            chunkMap.Add(chunk, (byte) index);

            return (byte) index;
        }

        PutChunk(new Chunk());

        var startIndices = new List<byte>();
        var continueIndices = new List<byte>();

        for (var i = 0; i < (0x110000 / Chunk.Length / 8); ++i) {
            var startBits = new Chunk();
            var continueBits = new Chunk();

            for (var j = 0; j < Chunk.Length; ++j) {
                for (var k = 0; k < 8; ++k) {
                    var code = (i * Chunk.Length + j) * 8 + k;
                    if (code < 0x80) continue;
                    if (!Rune.TryCreate(code, out var rune)) continue;

                    startBits[j] |= (byte) ((properties.IsStart(rune) ? 1 : 0) << k);
                    continueBits[j] |= (byte) ((properties.IsContinue(rune) ? 1 : 0) << k);
                }
            }

            startIndices.Add(PutChunk(startBits));
            continueIndices.Add(PutChunk(continueBits));
        }

        RemoveTrailingZeroes(startIndices);
        RemoveTrailingZeroes(continueIndices);

        var halfChunkMap = new Dictionary<HalfChunk, Queue<HalfChunk>>();
        foreach (var chunk in dense) {
            var (front, back) = HalfChunk.FromChunk(chunk);

            if (halfChunkMap.TryGetValue(front, out var queue)) {
                queue.Enqueue(back);
            }
            else {
                halfChunkMap.Add(front, new Queue<HalfChunk>([back]));
            }
        }

        var halfDense = new List<byte>();
        var denseToHalfDense = new Dictionary<byte, byte>();

        foreach (var chunk in dense) {
            var originalPos = chunkMap[chunk];
            if (denseToHalfDense.ContainsKey(originalPos)) continue;

            var index = halfDense.Count / HalfChunk.Length;
            Debug.Assert(index <= byte.MaxValue, "exceeded 256 half-dense chunks");
            denseToHalfDense.Add(originalPos, (byte) index);

            var (front, back) = HalfChunk.FromChunk(chunk);
            halfDense.AddRange(front);
            halfDense.AddRange(back);

            while (
                halfChunkMap.TryGetValue(back, out var queue) && queue.TryDequeue(out var next)
            ) {
                var concat = new Chunk();
                back[..].CopyTo(concat[.. HalfChunk.Length]);
                next[..].CopyTo(concat[HalfChunk.Length ..]);

                originalPos = chunkMap[concat];
                if (denseToHalfDense.ContainsKey(originalPos)) continue;

                index = halfDense.Count / HalfChunk.Length - 1;
                Debug.Assert(index <= byte.MaxValue, "exceeded 256 half-dense chunks");
                denseToHalfDense.Add(originalPos, (byte) index);

                halfDense.AddRange(next);
                back = next;
            }
        }

        return new Tables {
            StartIndices = startIndices.Select(i => denseToHalfDense[i]).ToArray(),
            ContinueIndices = continueIndices.Select(i => denseToHalfDense[i]).ToArray(),
            HalfDense = halfDense.ToArray(),
        };
    }

    private static void RemoveTrailingZeroes(List<byte> list)
    {
        var trailZeroIdx = int.MinValue;
        for (var i = list.Count - 1; 0 <= i; --i) {
            if (list[i] == 0) {
                trailZeroIdx = i;
            }
            else {
                break;
            }
        }

        if (trailZeroIdx >= 0) {
            list.RemoveRange(trailZeroIdx, list.Count - trailZeroIdx);
        }
    }
}

internal readonly record struct UcdField(int Start, int End, string Property)
{
    public static UcdField? Parse(string line, ReadOnlySpan<string> relevantProps)
    {
        const StringSplitOptions opts =
            StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries;

        var fields = line.Split(';', opts);
        Debug.Assert(fields.Length > 0);

        var comment = fields[1].IndexOf('#');
        var property = (comment >= 0 ? fields[1][0 .. comment] : fields[1]).Trim();

        if (!relevantProps.Contains(property)) return null;

        var range = fields[0].Split("..", opts);
        Debug.Assert(range.Length is 1 or 2);

        var start = int.Parse(range[0], NumberStyles.HexNumber, CultureInfo.InvariantCulture);
        var end =
            range.Length == 2
                ? int.Parse(range[1], NumberStyles.HexNumber, CultureInfo.InvariantCulture)
                : start;

        Debug.Assert(start <= end);

        return new UcdField(start, end, property);
    }
}

[InlineArray(Length)]
file struct Chunk : IEquatable<Chunk>
{
    public const int Length = 64;

    private byte _value;

    public readonly bool Equals(Chunk other)
    {
        ReadOnlySpan<byte> self = this;
        return self.SequenceEqual(other);
    }

    public override readonly bool Equals(object? obj) => obj is Chunk other && Equals(other);

    public override readonly int GetHashCode()
    {
        var hash = new HashCode();
        hash.AddBytes(this);
        return hash.ToHashCode();
    }

    public static bool operator ==(Chunk left, Chunk right) => left.Equals(right);
    public static bool operator !=(Chunk left, Chunk right) => !left.Equals(right);
}

[InlineArray(Length)]
file struct HalfChunk : IEquatable<HalfChunk>
{
    public const int Length = Chunk.Length / 2;

    private byte _value;

    public static (HalfChunk Front, HalfChunk Back) FromChunk(Chunk chunk)
    {
        var front = new HalfChunk();
        var back = new HalfChunk();

        chunk[.. Length].CopyTo(front);
        chunk[Length ..].CopyTo(back);

        return (front, back);
    }

    public readonly bool Equals(HalfChunk other)
    {
        ReadOnlySpan<byte> self = this;
        return self.SequenceEqual(other);
    }

    public override readonly bool Equals(object? obj) => obj is HalfChunk other && Equals(other);

    public override readonly int GetHashCode()
    {
        var hash = new HashCode();
        hash.AddBytes(this);
        return hash.ToHashCode();
    }

    public static bool operator ==(HalfChunk left, HalfChunk right) => left.Equals(right);
    public static bool operator !=(HalfChunk left, HalfChunk right) => !left.Equals(right);
}
