---
â—Šmeta:
  title: Weald ðŸŒ³
  version: 0.1.0
  non-numbered-headings:
    - Contents
---
Contents:
  - â—Štoc:
---
Introduction:
  - >
    Weald is a new programming language taking inspiration from C#, Rust, and Ruby.

    This document describes the languageâ€”mostly informally.
---
Lexical elements:
  - >
    This chapter covers the lexical structure of the language. The â—Š[source text] of a Weald program
    is transformed into a linear sequence of disjoint input elements: â—Ši[tokens], â—Ši[white space],
    â—Ši[newlines], and â—Ši[comments]. These input elements are produced by analysing the source textâ€™s
    code points, from left-to-right, then taking the longest sequence of code points that match a
    particular input element.

  - Source text:
      - â—Šsyn:
          â—Šcaption: source text
          Char: â—Šp any Unicode code point but not â—Š[ForbiddenChar]
          ForbiddenChar:
            - â—Šp any Control code point but not â—Š[Whitespace] or â—Š[Newline]
            - U+2028
            - U+2029
          End: â—Šp the physical end of input
      - >
        The source text of a Weald program is a sequence of Unicode code points, encoded as UTF-8.
        No other encoding is supported.

        The source text may start with a â—Šabbr[BOM][byte order mark] â—ŠU[FEFF] which is ignored for
        the purposes of lexical analysis.

        There are certain characters that are â—Šsyn[forbidden][ForbiddenChar] in source text; if
        source text contains these characters, even within strings or comments, it is an error. If
        the literal defines another way to represent a character, such as through an escape, it is
        allowed, since the literal character is not being represented.

  - White space:
      - â—Šsyn:
          â—Šcaption: white space
          Whitespace:
            - U+0020
            - U+0009
            - U+200E
            - U+200F
      - White space is used to separate input elements. It is otherwise insignificant and should be
        ignored. The only white space characters allowed are space and tab, plus the left-to-right
        and right-to-left marks.

  - Newlines:
      - â—Šsyn:
          â—Šcaption: newlines
          Newline:
            - U+000A
            - U+000D U+000A
      - Newlines are used to separate statements from one another. The only newline characters
        allowed are line feed and carriage return immediately followed by a line feed, i.e. either
        Unix-style LF or Windows-style CRLF.

  - Comments:
      - â—Šsyn:
          â—Šcaption: comments
          Comment:
            - "`//` LineCommentChar* CommentEnd"
            - "`/*` BlockCommentChar* `*/`"
          LineCommentChar: Char but not Newline
          BlockCommentChar: Char but not `*/`
          CommentEnd:
            - Newline
            - End
      - Comments are treated like white space and are ignored. The newline at the end of line
        comments is emitted as a normal newline token; newlines within block comments are also
        emitted.

  - Tokens:
      - â—Šsyn:
          â—Šcaption: tokens
          Token:
            - NameOrKeyword
            - Punctuation
            - Integer
            - Float
            - String
      - Tokens are the main input elements consumed by the parser. They include names, keywords,
        punctuation, numbers, and strings.

  - Names and keywords:
      - â—Šsyn:
          â—Šcaption: names and keywords
          NameOrKeyword:
            - Name but not Keyword
            - Keyword
      - >
        Names (also called identifiers) are used to refer to variables, types, and other entities in
        a program. Keywords are instances of names reserved for denoting syntactical constructs. The
        value of a user-defined name must not be equal to any keyword.

        Both names and keywords are case-sensitive.

      - Names:
          - â—Šsyn:
              â—Šcaption: names
              Name: NameStart NameContinue* (NameMedial NameContinue+)* NameFinal
              NameStart:
                - â—Šp â—Ši[XID_Start] but not â—Ši[Default_Ignorable_Code_Point]
                - â—Šp â—Ši[ID_Compat_Math_Start]
                - "`_`"
              NameContinue:
                - â—Šp â—Ši[XID_Continue] but not â—Ši[Default_Ignorable_Code_Point]
                - â—Šp â—Ši[ID_Compat_Math_Continue]
              NameMedial: "`-`"
              NameFinal: â—Šone-of ? !
          - >
            Names follow â—Š[UAX31-R1-1][https://www.unicode.org/reports/tr31/#R1] with the following
            profile, incorporating the Mathematical Compatibility Notation profile and the Default
            Ignorable Exclusion profile:
          - â—Šdl:
              Start: >
                XID_Start, plus ID_Compat_Math_Start, plus â—ŠU[005F], minus
                Default_Ignorable_Code_Point;
              Continue: >
                XID_Continue, plus ID_Compat_Math_Continue, minus Default_Ignorable_Code_Point;
              Medial: â—ŠU[002D].
          - >
            The Start set is a subset of the Continue set. Names may also be suffixed with at most
            one of question mark â—Šcode[?] or exclamation point â—Šcode[!].

            The value of a name is the result of normalising its code points using Normalisation
            Form C. Therefore, two names are equal if their NFC forms are equal.

      - Keywords:
          - â—Šsyn:
              â—Šcaption: keywords
              Keyword:
                - "`todo`"
          - >
            Keywords appear literally throughout this specification; every used keyword is listed
            above.

            All code points for all keywords are in the ASCII range, and no new keyword will be
            defined with code points outside that range.

  - Punctuation:
      - â—Šsyn:
          â—Šcaption: punctuation
          Punctuation: â—Šone-of ( ) [ ] { }
      - Punctuators are used to mark or separate syntactic constructs in a program. While only some
        punctuators are currently used, every ASCII code point that is also Pattern_Syntax is
        reserved for future use; this is a profile of
        â—Š[UAX-R3b-1][https://www.unicode.org/reports/tr31/#R3b].

  - Integers:
      - â—Šsyn:
          â—Šcaption: integers
          Integer: Sign? PositiveInteger
          Sign: â—Šone-of + -
          PositiveInteger:
            - IntegerDec
            - IntegerHex
            - IntegerBin
          IntegerDec: DigitDec+ (`_` DigitDec+)*
          IntegerHex: "`0x` DigitHex+ (`_` DigitHex+)*"
          IntegerBin: "`0b` DigitBin+ (`_` DigitBin+)*"
          DigitDec: â—Šone-of 0 1 2 3 4 5 6 7 8 9
          DigitHex: â—Šone-of 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
          DigitBin: â—Šone-of 0 1
      - >
        Integers represent whole numbers. They can be written in decimal, hexadecimal, or binary
        notation.

        The â—Šsyn[Char] immediately after â—Šsyn[Integer] must not be â—Šsyn[NameStart] or
        â—Šsyn[DigitDec].
      - â—Šnote: >
          For example, â—Šcode[2xl] is an error and not the integer â—Šcode[2] and the name â—Šcode[xl].

      - >
        â—Šb[Range of an integer.] An integer is a 64-bit, twoâ€™s-complement quantity, which ranges
        from âˆ’2â—Šsup[63] to 2â—Šsup[63 âˆ’ 1]. During runtime, operations on the integer value may
        overflow or underflow silently, with the result wrapping around.

      - >
        â—Šb[Determining the value of an integer.] Defined piecewise over the integer productions. If
        an overflow or underflow occurs, it is an error.
      - â—Šdl:
          â—Šsyn[Integer]: >
            the value of its â—Šsyn[PositiveInteger] component, then possibly negated if its
            â—Šsyn[Sign] is â—Šcode[-]
          â—Šsyn[IntegerDec]:
            fold each â—Šsyn[DigitDec] component as value = value Ã— 10 + digit, starting from 0
          â—Šsyn[IntegerHex]:
            fold each â—Šsyn[DigitHex] component as value = value Ã— 16 + digit, starting from 0
          â—Šsyn[IntegerBin]:
            fold each â—Šsyn[DigitBin] component as value = value Ã— 2 + digit, starting from 0
          â—Šsyn[DigitDec]: map each character to its literal decimal value
          â—Šsyn[DigitHex]: map each character to its literal hexadecimal value
          â—Šsyn[DigitBin]: map each character to its literal binary value

  - Floats:
      - â—Šsyn:
          â—Šcaption: floats
          Float: Sign? PositiveFloat
          PositiveFloat:
            - PositiveInteger `.` PositiveInteger FloatExponent?
            - PositiveInteger FloatExponent
          FloatExponent: "`e` Integer"
      - >
        Floats represent fractional numbers.

        The â—Šsyn[Char] immediately after â—Šsyn[Float] must not be â—Šsyn[NameStart] or â—Šsyn[DigitDec].
      - â—Šnote: >
          For example, â—Šcode[3.14e] is an error and not the float â—Šcode[3.14] and the name â—Šcode[e].

      - >
        â—Šb[Range of a float.] A float64 is an IEEE-754 64-bit quantity, with 53 bits of significand
        precision (approximately 15â€“17 decimal digits). It can represent finite values up to
        Â±1.8Ã—10â—Šsup[308], plus â—Šabbr[Â±âˆž][positive/negative infinity] and â—Šabbr[NaN][not a number].
        Integers in the range Â±2â—Šsup[53] are represented exactly.

      - >
        â—Šb[Determining the value of a float.] Defined piecewise over the float productions. If a
        literal cannot be represented exactly, it is rounded to the nearest representable value,
        using round-half-to-even.
      - â—Šdl:
          â—Šsyn[Float]: >
            the value of its â—Šsyn[PositiveFloat] component, then possibly negated if its â—Šsyn[Sign]
            is â—Šcode[-]
          â—Šsyn[PositiveFloat]: >
            the formula (w + f Ã— 10â—Šsup[âˆ’n]) Ã— 10â—Šsup[e], where: w is the â—Šsyn[PositiveInteger]
            component before the dot; f is the â—Šsyn[PositiveInteger] component after the dot
            (defaulting to 0 if not present); n is the length of the component after the dot; and e
            is the value of â—Šsyn[FloatExponent] (defaulting to 0 if not present)
          â—Šsyn[FloatExponent]: >
            the value of its â—Šsyn[Integer] component
