---
◊meta:
  title: Weald 🌳
  version: 0.1.0
  non-numbered-headings:
    - Contents
---
Contents:
  - ◊toc:
---
Introduction:
  - >
    Weald is a new programming language taking inspiration from C#, Rust, and Ruby.

    This document describes the language—mostly informally.
---
Lexical syntax:
  - >
    This chapter covers the lexical structure of the language. The ◊[source text] of a Weald program
    is transformed into a linear sequence of disjoint input elements: ◊i[tokens], ◊i[white space],
    ◊i[newlines], and ◊i[comments]. These input elements are produced by analysing the source text’s
    code points, from left-to-right, then taking the longest sequence of code points that match a
    particular input element.

  - Source text:
      - ◊syn:
          ◊caption: source text
          Char: ◊p any Unicode code point but not ◊[ForbiddenChar]
          ForbiddenChar:
            - ◊p any Control code point but not ◊[Whitespace] or ◊[Newline]
            - U+2028
            - U+2029
          End: ◊p the physical end of input
      - >
        The source text of a Weald program is a sequence of Unicode code points, encoded as UTF-8.
        No other encoding is supported.

        The source text may start with a ◊abbr[BOM][byte order mark] ◊U[FEFF] which is ignored for
        the purposes of lexical analysis.

        There are certain characters that are ◊syn[forbidden][ForbiddenChar] in source text; if
        source text contains these characters, even within strings or comments, it is an error. If
        the literal defines another way to represent a character, such as through an escape, it is
        allowed, since the literal character is not being represented.

  - White space:
      - ◊syn:
          ◊caption: white space
          Whitespace:
            - U+0020
            - U+0009
      - >
        White space is used to separate input elements. It is otherwise insignificant and should be
        ignored. The only white space characters allowed are space and tab.

  - Newlines:
      - ◊syn:
          ◊caption: newlines
          Newline:
            - U+000A
            - U+000D U+000A
          Newlines: Newline+
      - >
        Newlines are used to separate statements from one another. The only newline characters
        allowed are line feed and carriage return immediately followed by a line feed, i.e. either
        Unix-style LF or Windows-style CRLF.

  - Comments:
      - ◊syn:
          ◊caption: comments
          Comment:
            - "`//` LineCommentChar* CommentEnd"
            - "`/*` BlockCommentChar* `*/`"
          LineCommentChar: Char but not Newline
          BlockCommentChar: Char but not `*/`
          CommentEnd:
            - Newline
            - End
      - >
        Comments are treated like white space and are ignored. The newline at the end of line
        comments is emitted as a normal newline token; newlines within block comments are also
        emitted.

  - Tokens:
      - ◊syn:
          ◊caption: tokens
          Token:
            - NameOrKeyword
            - Punctuation
            - Number
            - String
      - >
        Tokens are the main input elements consumed by the parser. They include names, keywords,
        punctuation, numbers, and strings.

  - Names and keywords:
      - ◊syn:
          ◊caption: names and keywords
          NameOrKeyword:
            - Name but not Keyword
            - Keyword
      - >
        Names (also called identifiers) are used to refer to variables, types, and other entities in
        a program. Keywords are instances of names reserved for denoting syntactical constructs. The
        value of a user-defined name must not be equal to any keyword.
      - Both names and keywords are case-sensitive.
      - Names:
          - ◊syn:
              ◊caption: names
              Name: NameStart NameContinue* (NameMedial NameContinue+)* NameFinal
              NameStart:
                - ◊p XID_Start
                - "`_`"
              NameContinue: ◊p XID_Continue
              NameMedial: "`-`"
              NameFinal: ◊one-of ? !
          - >
            Names follow ◊[UAX31-R1-1][https://www.unicode.org/reports/tr31/#R1] with the following
            profile, incorporating the Mathematical Compatibility Notation profile:
          - ◊dl:
              Start: XID_Start, plus ID_Compat_Math_Start, plus ◊code[_] underscore
              Continue: XID_Continue, plus ID_Compat_Math_Continue (this includes underscore)
              Medial: ◊code[-] hyphen-minus
          - Names may also be suffixed with at most one of question mark ◊code[?] or exclamation
            point ◊code[!].
          - >
            The value of a name is the result of normalising its code points using Normalisation
            Form C. Therefore, two names are equal if their NFC forms are equal.

      - Keywords:
          - ◊syn:
              ◊caption: keywords
              Keyword:
                - "`todo`"
          - >
            All code points in any keyword are in the ASCII range, and no new keyword will be
            defined with code points outside that range.

  - Punctuation:
      - ◊syn:
          ◊caption: punctuation
          Punctuation: ◊one-of ( ) [ ] { }
      - >
        Punctuators are used to mark or separate syntactic constructs in a program. While only some
        punctuators are currently used, every ASCII code point that is also Pattern_Syntax is
        reserved for future use; this is a profile of
        ◊[UAX-R3b-1][https://www.unicode.org/reports/tr31/#R3b].
