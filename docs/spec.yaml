---
â—Šmeta:
  title: Weald ðŸŒ³ Language Specification
  version: 0.2.0
---
Introduction:
  - >
    Weald is a new programming language taking inspiration from C#, Rust, Ruby, and TypeScript.

    This document describes the languageâ€”mostly informally.
---
Lexical elements:
  - >
    This chapter covers the lexical structure of the language. The â—Š[source text] of a Weald program
    is transformed into a linear sequence of disjoint input elements: â—Ši[tokens], â—Ši[white space],
    â—Ši[newlines], and â—Ši[comments]. These input elements are produced by analysing the source textâ€™s
    code points, from left-to-right, then taking the longest sequence of code points that match a
    particular input element.

  - Source text:
      - â—Šsyn:
          â—Šcaption: source text, characters, and initials
          SourceText: Bom? Hashbang? Char* End
          Bom: U+FEFF
          Hashbang: "`#!` CommentChar* CommentEnd"
          Char: â—Šp any Unicode code point but not â—Š[ForbiddenChar]
          ForbiddenChar:
            - â—Šp any Control code point but not â—Š[Whitespace] or â—Š[Newline]
            - â—Šp any Surrogate code point
            - U+2028
            - U+2029
          End: â—Šp the physical end of input
      - >
        The source text of a Weald program is a sequence of Unicode code points, encoded as UTF-8.
        No other encoding is supported.

        The source text may start with a â—Šabbr[BOM][byte order mark] â—ŠU[FEFF] which is ignored for
        the purposes of lexical analysis. It can also start with a hashbang line, which is also
        ignored.

        There are certain characters that are â—Šsyn[forbidden][ForbiddenChar] in source text; if
        source text contains these characters, even within strings or comments, it is an error. If
        the literal defines another way to represent a character, such as through an escape, it is
        allowed, since the literal character is not being represented.

      - â—Šrationale: >
          Unicode and UTF-8 are common-sense standards, and usage of other encodings is very minimal
          in 2026. Control characters are forbidden because there is no good reason to have them
          unescaped in a program (same for surrogates). The â—ŠU[2028] and â—ŠU[2029] characters are
          forbidden because whilst Unicode recommends them for separating lines, Weald does not
          support them, and forbidding them outright prevents spoofing attacks.

  - White space:
      - â—Šsyn:
          â—Šcaption: white space
          Whitespace:
            - U+0020
            - U+0009
            - U+200E
            - U+200F
      - >
        White space is used to separate input elements. It is otherwise insignificant and should be
        ignored. The only white space characters allowed are space and tab, plus the bidirectional
        marks.

        The bidirectional marks must not be the only separators between two â—Š[name][Names and
        keywords] tokens.

      - â—Šrationale: >
          Most common languages allow either all Unicode code points with property
          â—Ši[Pattern_White_Space] as white space or allow some subset of it, often including very
          rarely used characters such as form feed and vertical tab. Weald only allows space and
          tab, as those are essentially the only characters used for white space in modern
          programming.

          Bidirectional marks are allowed because they are needed for Unicode text layout. They are
          forbidden as name separators because they are non-spacing, with no advance width.

  - Newlines:
      - â—Šsyn:
          â—Šcaption: newlines
          Newline:
            - U+000A
            - U+000D? U+000A
      - Newlines are used to separate statements from one another. They are the usual LF, CRLF, or
        CR.

      - â—Šrationale: >
          Earlier in development, Weald explicitly disallowed CR newlines since they are very rarely
          used. But this made the lexer more complex for little benefit, so they are allowed,
          alongside the very common LF (Unix-style) and CRLF (Windows-style) newlines.

  - Comments:
      - â—Šsyn:
          â—Šcaption: comments
          Comment:
            - "`--` CommentChar* CommentEnd"
          CommentChar: Char but not Newline
          CommentEnd:
            - Newline
            - End
      - Comments are treated like white space and are ignored. The newline at the end of line
        comments is emitted as a normal newline token, if present.

      - â—Šrationale: >
          Aesthetically, the double dash is pretty neat.

          Block comments were left out as they are not usually that common, and line comments can do
          everything they can without nesting issues. IDE support can help with commenting out large
          blocks of code.

  - Tokens:
      - â—Šsyn:
          â—Šcaption: tokens
          Token:
            - NameOrKeyword
            - Boolean
            - Integer
            - Float
            - String
            - Punctuation
      - Tokens are the main input elements consumed by the parser. They include names, keywords,
        booleans, integers, floats, and strings.

  - Names and keywords:
      - â—Šsyn:
          â—Šcaption: names and keywords
          NameOrKeyword:
            - Name but not Keyword
            - Keyword
      - >
        Names (also called identifiers) are case-sensitive labels used to refer to variables, types,
        and other entities in a program. Keywords are instances of names reserved for denoting
        syntactical constructs. The value of a user-defined name must not be equal to any keyword.

        The â—Šsyn[Char] immediately after â—Šsyn[NameOrKeyword] must not be â—Šsyn[NameContinue] or
        â—Šsyn[NameMedial].

      - Names:
          - â—Šsyn:
              â—Šcaption: names
              Name: NameStart NameContinue* (NameMedial NameContinue+)* NameFinal
              NameStart:
                - â—Šp â—Ši[XID_Start] but not â—Ši[Default_Ignorable_Code_Point]
                - â—Šp â—Ši[ID_Compat_Math_Start]
                - "`_`"
              NameContinue:
                - â—Šp â—Ši[XID_Continue] but not â—Ši[Default_Ignorable_Code_Point]
                - â—Šp â—Ši[ID_Compat_Math_Continue]
              NameMedial: "`-`"
              NameFinal: â—Šone-of ? !
          - >
            Names follow â—Š[UAX31-R1-1][https://www.unicode.org/reports/tr31/#R1] with the following
            profile, incorporating the Mathematical Compatibility Notation profile and the Default
            Ignorable Exclusion profile:
          - â—Šdl:
              Start: >
                XID_Start, plus ID_Compat_Math_Start, plus â—ŠU[005F], minus
                Default_Ignorable_Code_Point;
              Continue: >
                XID_Continue, plus ID_Compat_Math_Continue, minus Default_Ignorable_Code_Point;
              Medial: â—ŠU[002D].
          - >
            The Start set is a subset of the Continue set. Names may also be suffixed with at most
            one of question mark â—Šcode[?] or exclamation point â—Šcode[!].

            The value of a name is the result of normalising its code points using Normalisation
            Form C. Therefore, two names are equal if their NFC forms are equal.

          - â—Šrationale: >
              The vast majority of code uses ASCII exclusively for names, so in theory full Unicode
              support is dispensable, but itâ€™s cool, so itâ€™s in. Math symbols are also in. The fact
              that kebab-case is allowed probably feels strange, but I love kebab-case.

      - Keywords:
          - â—Šsyn:
              â—Šcaption: keywords
              Keyword: â—Šone-of _ true false
          - >
            Keywords appear literally throughout this specification; every used keyword is listed
            above.

            All keywords use only lowercase ASCII letters, and no new keyword will be defined with
            code points outside that range.

  - Booleans:
      - â—Šsyn:
          â—Šcaption: booleans
          Boolean:
            - "`true`"
            - "`false`"
      - >
        Boolean literals represent a logical value that can be either true or false.

  - Integers:
      - â—Šsyn:
          â—Šcaption: integers
          Integer: Sign? PositiveInteger
          Sign: â—Šone-of + -
          PositiveInteger:
            - IntegerDec
            - IntegerHex
            - IntegerBin
          IntegerDec: DigitDec+ (`_` DigitDec+)*
          IntegerHex: "`0x` DigitHex+ (`_` DigitHex+)*"
          IntegerBin: "`0b` DigitBin+ (`_` DigitBin+)*"
          DigitDec: â—Šone-of 0 1 2 3 4 5 6 7 8 9
          DigitHex: â—Šone-of 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
          DigitBin: â—Šone-of 0 1
      - >
        Integers represent whole numbers. They can be written in decimal, hexadecimal, or binary
        notation.

        The â—Šsyn[Char] immediately after â—Šsyn[Integer] must not be â—Šsyn[NameContinue] or
        â—Šsyn[NameMedial].
      - â—Šnote: >
          For example, â—Šcode[2xl] is an error and not the integer â—Šcode[2] and the name â—Šcode[xl].

      - >
        â—Šb[Range of an integer.] An integer literal is a 128-bit, twoâ€™s-complement quantity, which
        ranges from âˆ’2â—Šsup[127] to 2â—Šsup[127 âˆ’ 1]. It is an error if the literal is outside this
        range. The actual value of an integer literal depends on its type, which is inferred from
        context.

      - >
        â—Šb[Types of integers.] The type of an integer can be either Nat, Int, or Byte.
      - â—Šdl:
          Nat: unsigned 64-bit value ranging from 0 to 2â—Šsup[64 âˆ’ 1]
          Int: signed 64-bit value ranging from âˆ’2â—Šsup[63] to 2â—Šsup[63 âˆ’ 1]
          Byte: unsigned 8-bit value ranging from 0 to 255
      - >
        This type is inferred from context:
      - â—Šul:
          - If the literal has a negative sign, the type is forced to Int.
          - If the type can â—Ši[uniquely] be determined from context, it is that type.
          - If the context under-constrains the type, it defaults to Nat.
          - If the context over-constrains the type, it is an error.

      - >
        â—Šb[Determining the value of an integer.] The value of an integer is the value of its sign
        and digits, ignoring underscore separators. This value is interpreted in a specific radix
        depending on the prefix: â—Šcode[0x] indicates base 16, â—Šcode[0b] indicates base 2, and no
        prefix indicates base 10. The prefix itself is not part of the value.

        In any of the above cases, the number is negated if it has a negative sign. Then, the final
        value is checked to fit within its inferred typeâ€™s range; if it does not fit within the
        integer range of its type, it is an error.

      - â—Šrationale: >
          â—Šb[The types.] The three integer types were chosen for their usefulness. The odd one out
          is Byte; that one is useful because dealing with files in arbitrary formats is very
          common, and having a dedicated type that isnâ€™t oversized for this purpose is useful.

          Itâ€™s useful to have a full set of integer types like C or Rust, that include â€œmidwayâ€
          types like 16-bit integers and 32-bit integers. But for a more high-level language like
          Weald, the added complexity is not outweighed by the benefits. In the interest of
          simplicity, I settled on the three types above.

          Also in the interest of simplicity and for preventing indexing bugs, Java kept out signed
          integers. I thought that was too far; unsigned integers are useful because you often do
          really want to make sure something cannot be negativeâ€”most often for an index. Overflow is
          a danger, but say you subtract from zero, and you accidentally index into an array with
          the resulting value that wrapped around (which is probably close to 2â—Šsup[64 âˆ’ 1]): the
          index operation will fail, because itâ€™s out of bounds; same as âˆ’1 or 9â€‰999â€‰999 would.
          Using signed or unsigned integers for indexing is orthogonal to the permanently
          necessaryâ€”and enforcedâ€”bounds checking.

          â—Šb[The syntax.] The hexadecimal and binary prefixes only accept lowercase â—Štt[x] or
          â—Štt[b]. I donâ€™t know why other languages allow uppercase prefixes, but I thought it was
          rather unnecessary.

          Most other languages donâ€™t parse the positive/negative sign as part of the integer
          literal, instead having it be an application of unary operations. This is totally fine,
          but it adds a bit of complexity for bounds checking the literals, as the parser needs to
          do that check by inspecting the syntax nodes. Parsing the sign as part of the integer
          literal is simpler.

  - Floats:
      - â—Šsyn:
          â—Šcaption: floats
          Float: Sign? PositiveFloat
          PositiveFloat:
            - IntegerDec `.` IntegerDec FloatExponent?
            - IntegerDec FloatExponent
          FloatExponent: "`e` Sign? IntegerDec"
      - >
        Floats represent rational numbers and approximations of irrational numbers.

        The â—Šsyn[Char] immediately after â—Šsyn[Float] must not be â—Šsyn[NameContinue] or
        â—Šsyn[NameMedial].
      - â—Šnote: >
          For example, â—Šcode[3.14e] is an error and not the float â—Šcode[3.14] and the name â—Šcode[e].

      - >
        â—Šb[Range of a float.] A float is an IEEE-754 binary64 value, with 53 bits of significand
        precision (approximately 15â€“17 decimal digits). It can represent finite values up to
        Â±1.8Ã—10â—Šsup[308], plus â—Šabbr[Â±âˆž][positive/negative infinity] and â—Šabbr[NaN][not a number].
        Integers in the range Â±2â—Šsup[53] are represented exactly.

      - >
        â—Šb[Determining the value of a float.] Compute the mathematical value represented by the
        literal, ignoring underscore separators. Round the value to fit within a binary64 value
        using the â—Štt[roundTiesToEven] rounding mode. If the absolute value is too large to
        represent (overflow), return a signed infinity. If the absolute value is too small to
        represent (underflow), return a subnormal or signed zero as per IEEE 754 rules.

      - â—Šrationale: >
          A lot of languages allow floats to be represented with a leading dot â—Štt[.123] or trailing
          dot â—Štt[123.], but this creates unneeded complexity in the lexer just to save one
          character (the zero). So Weald does not interpret leading or trailing dots as float
          literals; youâ€™ll have to put the zero in.

          The â—Štt[e] exponent prefix is not allowed to be uppercase in the interest of simplicity,
          much like the â—Štt[0x]/â—Štt[0b] prefix case for integers.

  - Strings:
      - â—Šsyn:
          â—Šcaption: strings and escape sequences
          String:
            - StringStd
            - StringRaw

          â—Šseparator_:

          StringStd:
            - StringStdLine
            - StringStdBlock

          StringStdLine: >
            `"` StringStdLineChar* `"`
          StringStdLineChar: CharEscapable but not StringStdLineEnd
          StringStdLineEnd:
            - Newline
            - '`"`'

          StringStdBlock: >
            `"""` StringStdBlockChar* `"""`
          StringStdBlockChar: >
            CharEscapable but not `"""`

          â—Šseparator__:

          StringRaw:
            - StringRawLine
            - StringRawBlock

          StringRawLine: >
            '`' StringRawLineChar* '`'
          StringRawLineChar: Char but not StringRawLineEnd
          StringRawLineEnd:
            - Newline
            - "'`'"

          StringRawBlock: >
            '```' StringRawBlockChar* '```'
          StringRawBlockChar: >
            CharEscapable but not '```'

          â—Šseparator___:

          CharEscapable:
            - Char but not `\`
            - "`\\` Escape"
          Escape:
            - EscapeBasic
            - EscapeUnicode
            - EscapeContinuation
          EscapeBasic: â—Šone-of " \ e n r t
          EscapeUnicode:
            - "`x` DigitHex DigitHex"
            - "`u` DigitHex DigitHex DigitHex DigitHex"
            - "`u{` DigitHex+ `}`"
          EscapeContinuation: Newline Whitespace*
      - >
        A string is a sequence of zero or more Unicode code points, resolving to a â—Ši[content]
        value. Strings have with multiple literal forms, described below.

        â—Šb[Line strings.] Enclosed in one set of quotes. They cannot contain newlines or their own
        quotes. The content of a line string is the sequence of code points within the quotes.

        â—Šb[Block strings.] Enclosed in a triple set of quotes. They can span multiple lines and may
        contain their quotes (but not three consecutively). The content of a block string is the
        sequence of code points within the triple quotes, applying the following transformations in
        order:

      - â—Šol:
          - Trim leading and trailing white space and newlines
          - Split the sequence into lines at each â—Šsyn[Newline]
          - For each line, remove the common leading white space, ignoring blank lines
          - Join the resulting lines with â—ŠU[000A]

      - >
        The â—Ši[content] can then be further interpreted in two ways: standard and raw. In the
        standard form, â—Ši[escape sequences] are replaced by their corresponding values. In the raw
        form, escape sequences are treated as literal code points.

        â—Šb[Standard interpretation.] Escape sequences are replaced by their corresponding values as
        per the following table:

      - â—Šcsv:
          â—Šcaption: escape sequences
          â—Šdata: |
            Escape sequence,       Replacement
            â—Štt[\â—Šsyn[Newline]],   continuation escape
            "â—Štt[\""]",            â—ŠU[0022]
            â—Štt[\\],               â—ŠU[005C]
            â—Štt[\e],               â—ŠU[001B]
            â—Štt[\n],               â—ŠU[000A]
            â—Štt[\r],               â—ŠU[000D]
            â—Štt[\t],               â—ŠU[0009]
            â—Štt[\uâ—Ši[HHHH]],       the code point U+â—Ši[HHHH]
            â—Štt[\u{â—Ši[Hâ€¦]â—Štt[}]],  the code point U+â—Ši[Hâ€¦]
            â—Štt[\xâ—Ši[HH]],         the code point U+00â—Ši[HH]

      - Any other escape sequences are an error. Also, the Unicode â—Šcode[\u \x] escape sequences
        require a valid code point in hexadecimal.

      - â—Šb[Continuation escapes.] When this escape is encountered, the newline and any white space
        after are replaced by an empty string. That is, the continuation escape allows line strings
        to span multiple lines. Block strings may also use it.

      - â—Šb[Raw interpretation.] Escape sequences are kept verbatim. Raw strings have their quotes
        replaced by backticks.

      - â—Šrationale: >
          The string syntax is fairly standard and similar to C#â€™s. The main difference is the valid
          escape sequences: I removed most of the rarer ones such as â—Štt[\v], â—Štt[\f], and â—Štt[\a],
          and added â—Štt[\e]. The rarer escape sequences are fairly uninteresting when you have
          access to Unicode escapes, but â—Štt[\e] is very useful for printing ANSI escape sequences
          used in terminal formattingâ€”â—Šcode["Hello, \e[31mworld\e[0m!"] is more readable than
          â—Šcode["Hello, \u001B[31mworld\u001B[0m!"].

          Raw strings use backticks instead of C#â€™s â—Štt[@]-prefix so that you can write quotes
          within strings without escaping them, which is a fairly common need.

          Interpolated strings will be added later.

  - Punctuation:
      - â—Šsyn:
          â—Šcaption: punctuation
          Punctuation: >
            â—Šone-of ( ) [ ] { } * \ && % ^ | || + - , : . / < <= = == ! != >= >
      - Punctuators are used to mark or separate syntactic constructs in a program. While only some
        punctuators are currently used, every ASCII code point that is also Pattern_Syntax is
        reserved for future use; this is a profile of
        â—Š[UAX-R3b-1][https://www.unicode.org/reports/tr31/#R3b].
